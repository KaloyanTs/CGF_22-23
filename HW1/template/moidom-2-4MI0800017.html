<!DOCTYPE html>

<!-- Калоян Цветков, група 2, ф.н. 4MI0800017 -->

<html>

<head>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<script src="three.min.js"></script>
	<script src="OrbitControls.js"></script>
</head>

<body>
	<script>
		const FN = '4MI0800017'; // факултетен номер 
	</script>

	<script src="init.js"></script>
	<script src="CSG.js"></script>

	<script>

		// 1. преименувайте файла на moidom-g-fn.html
		//    g=номер на група, а fn=факултетен номер
		//
		// 2. сменете стойността на константата FN да
		//    е факултетния номер, за да се генерират
		//    сцената, земята и контурът на къщата ви
		//
		// 3. едва тогава почвайте да строите стените
		//    и да добавяте исканите обекти по стаите
		//
		// 4. в init.js се прави глобален обект scene
		//    и в него трябва да сложите обектите си!
		//
		// 5. кубът по-долу е само за пример как може
		//    да се слагат обекти, които правят сянка

		requestAnimationFrame(drawFrame);

		function wall(from, to, height, thickness, color) {
			var length = Math.sqrt((from[0] - to[0]) * (from[0] - to[0]) + (from[1] - to[1]) * (from[1] - to[1]));
			var geometry = new THREE.BoxGeometry(length, height, thickness);
			var material = new THREE.MeshPhongMaterial({ color: color });
			var w = new THREE.Mesh(geometry, material);
			w.rotation.y = Math.atan((from[1] - to[1]) / (from[0] - to[0]));
			w.position.set((from[0] + to[0]) / 2, height / 2, -(from[1] + to[1]) / 2);
			w.castShadow = true;
			w.receiveShadow = true;
			return w;
		}

		var geometry, material;

		//geometry = new THREE.BoxGeometry(1, 1, 1),
		//	material = new THREE.MeshPhongMaterial({ color: 'crimson', shininess: 100 });

		var cube = new THREE.Mesh(geometry, material);
		cube.position.set(0, .5, 0);
		cube.receiveShadow = true;
		cube.castShadow = true;

		cube.scale.z = 2;

		scene.add(cube);

		const wallThickness = .2;
		const wallColor = 'salmon';
		const doorColor = 'blue';

		scene.add(wall([3, -7 - wallThickness / 2], [3, -1 - wallThickness / 2], 3, wallThickness, wallColor));
		scene.add(wall([3 - wallThickness / 2, -7], [-4 - wallThickness / 2, -7], 3, wallThickness, wallColor));
		scene.add(wall([-4, -7 + wallThickness / 2], [-4, 5 + wallThickness / 2], 3, wallThickness, wallColor));
		scene.add(wall([-4 + wallThickness / 2, 5], [9 + wallThickness / 2, 5], 3, wallThickness, wallColor));
		scene.add(wall([9, 5 - wallThickness / 2], [9, -1 - wallThickness / 2], 3, wallThickness, wallColor));
		scene.add(wall([9 - wallThickness / 2, -1], [3 - wallThickness / 2, -1], 3, wallThickness, wallColor));
		scene.add(wall([3, -3.5], [3, -2.5], 2, 2 * wallThickness, doorColor));
		scene.add(wall([5, -1 + wallThickness / 2], [5, 5 - wallThickness / 2], 3, wallThickness, wallColor));
		scene.add(wall([3, -1 + wallThickness / 2], [3, 1], 3, wallThickness, wallColor));
		scene.add(wall([-1, 2], [-1, 5 - wallThickness / 2], 3, wallThickness, wallColor));
		var tiltedL = Math.sqrt(3 * wallThickness * wallThickness + 16 * wallThickness + 17);
		scene.add(wall([-1.0735848395, 2.092452789], [3.0735843719, 0.9075455745], 3, wallThickness, wallColor));
		scene.add(wall([3 - wallThickness / 2, -4], [-4 + wallThickness / 2, -4], 3, wallThickness, wallColor));

		var toasters = [];

		var t1 = new THREE.Group();

		geometry = new THREE.CylinderGeometry(1, 1.3, 2, 32, 20);
		material = new THREE.MeshPhongMaterial({ color: 'white' });
		var part = new THREE.Mesh(geometry, material);
		part.position.set(0, 1.3, 0);
		part.scale.z = 1.5;

		var csgBody = new CSG();
		geometry = new THREE.BoxGeometry(.4, 1.3, 1.3);
		material = new THREE.MeshPhongMaterial({ color: 'yellow' });
		var slice1hole = new THREE.Mesh(geometry, material);
		slice1hole.position.set(.3, 2.2, 0);
		var slice2hole = new THREE.Mesh(geometry, material);
		slice2hole.position.set(-.3, 2.1, 0);
		csgBody.subtract([part, slice1hole, slice2hole]);

		t1.add(csgBody.toMesh());

		material = new THREE.MeshPhongMaterial({ color: 'grey' });
		geometry = new THREE.CylinderGeometry(1.28, 1.28, .3, 32, 20);
		part = new THREE.Mesh(geometry, material);
		part.position.set(0, .15, 0);
		part.scale.z = 1.5;
		t1.add(part);

		geometry = new THREE.BoxGeometry(.3, 1, 1);
		material = new THREE.MeshPhongMaterial({ color: 'yellow' });
		var slice1 = new THREE.Mesh(geometry, material);
		slice1.position.set(.3, 2.2, 0);
		var slice2 = new THREE.Mesh(geometry, material);
		slice2.position.set(-.3, 2.1, 0);
		t1.add(slice1);
		t1.add(slice2);


		var lever = new THREE.Group();

		geometry = new THREE.SphereGeometry(.1, 32, 16);
		material = new THREE.MeshPhongMaterial({ color: 'red' });
		var ball = new THREE.Mesh(geometry, material);

		geometry = new THREE.CylinderGeometry(.03, .03, .5, 32, 20);
		material = new THREE.MeshPhongMaterial({ color: 'red' });
		var long = new THREE.Mesh(geometry, material);
		long.rotation.x = Math.PI / 2 - Math.atan(.45 / 2);
		long.position.set(0, -.05, -.25);

		lever.add(long);
		lever.add(ball);

		lever.position.set(0, 2, 1.7);

		t1.add(lever);

		geometry = new THREE.BoxGeometry(.2, 1.75, .2);
		material = new THREE.MeshPhongMaterial({ color: 'black' });
		part = new THREE.Mesh(geometry, material);
		part.position.set(0, 1.42, 1.675);
		part.rotation.x = -Math.atan(.45 / 2);
		t1.add(part);

		geometry = new THREE.CylinderGeometry(.75, .95, .3, 64, 10);
		material = new THREE.MeshPhongMaterial({ color: 0x800507 });
		part = new THREE.Mesh(geometry, material);
		part.position.set(0, 2.3, 0);
		part.scale.z = 1.5;

		geometry = new THREE.BoxGeometry(.47, 1.3, 1.37);
		var slice1hole = new THREE.Mesh(geometry, material);
		var slice2hole = new THREE.Mesh(geometry, material);
		slice1hole.position.set(.3, 2.2, 0);
		slice2hole.position.set(-.3, 2.1, 0);
		csgBody = new CSG();
		csgBody.subtract([part, slice1hole, slice2hole]);
		t1.add(csgBody.toMesh());


		t1.position.set(7, 0, -2);
		toasters.push(t1);
		scene.add(t1);

		var t2 = t1.clone();
		t2.scale.set(.5, .5, .5);
		t2.position.set(0, 10, 0);
		toasters.push(t2);
		scene.add(t2);


		geometry = new THREE.CylinderGeometry(.1, .1, 1.2, 16, 8);
		material = new THREE.MeshPhongMaterial({ color: 'orange' });
		var leftLeg = new THREE.Mesh(geometry, material);
		leftLeg.position.y = -.6;
		leftLeg.position.x = .2;
		leftLeg.rotation.z = Math.PI / 20;
		var rightLeg = new THREE.Mesh(geometry, material);
		rightLeg.position.y = -.6;
		rightLeg.position.x = -.2;
		rightLeg.rotation.z = -Math.PI / 20;
		var body = new THREE.Mesh(geometry, material);
		body.position.y = .6;

		geometry = new THREE.SphereGeometry(.5, 32, 16);
		var head = new THREE.Mesh(geometry, material);
		head.position.y = 1.7;

		var person = new THREE.Group();
		person.add(leftLeg);
		person.add(rightLeg);
		person.add(body);
		person.add(head);

		scene.add(person);

		var alpha = Math.PI / 4;
		var slice1Bounce = .7;
		var personAlpha = 0;
		var personX, personZ;
		function drawFrame() {
			requestAnimationFrame(drawFrame);

			for (var i = 0; i < toasters.length; ++i) {
				toasters[i].children[2].position.y = 2.4 - .7 * Math.sin(alpha) * Math.sin(alpha) - .4 * Math.cos(alpha);
				toasters[i].children[3].position.y = 2.4 - .9 * Math.sin(alpha + .3) * Math.sin(alpha + .3) - .9 * Math.cos(alpha);
				toasters[i].children[4].position.y = .8 * Math.sin(alpha + .1) + 1.5;
				toasters[i].children[4].position.z = 2 - .18 * Math.sin(alpha + .1);
			}

			personX = 9 * Math.sqrt(Math.abs(Math.cos(personAlpha)));
			if (Math.cos(personAlpha) < 0) personX = -personX;
			personZ = 9 * Math.sqrt(Math.abs(Math.sin(personAlpha)));
			if (Math.sin(personAlpha) < 0) personZ = -personZ;
			person.position.set(1 + personX,
				.6,
				personZ);
			person.rotation.y = -personAlpha;

			personAlpha += 0.02;//fix
			alpha += 0.1;
			renderer.render(scene, camera);
		};

	</script>

</body>

</html>