<!DOCTYPE html>

<!-- Калоян Цветков, група 2, ф.н. 4MI0800017 -->

<html>

<head>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<script src="three.min.js"></script>
	<script src="OrbitControls.js"></script>
</head>

<body>
	<script>
		const FN = '4MI0800017'; // факултетен номер 
	</script>

	<script src="init.js"></script>
	<script src="CSG.js"></script>

	<script>

		// 1. преименувайте файла на moidom-g-fn.html
		//    g=номер на група, а fn=факултетен номер
		//
		// 2. сменете стойността на константата FN да
		//    е факултетния номер, за да се генерират
		//    сцената, земята и контурът на къщата ви
		//
		// 3. едва тогава почвайте да строите стените
		//    и да добавяте исканите обекти по стаите
		//
		// 4. в init.js се прави глобален обект scene
		//    и в него трябва да сложите обектите си!
		//
		// 5. кубът по-долу е само за пример как може
		//    да се слагат обекти, които правят сянка

		requestAnimationFrame(drawFrame);

		var doors = [];

		function wall(from, to, height, thickness, color, hasDoor, doorPosition, doorDim) {
			var length = Math.sqrt((from[0] - to[0]) * (from[0] - to[0]) + (from[1] - to[1]) * (from[1] - to[1]));
			var geometry = new THREE.BoxGeometry(length, height, thickness);
			var material = new THREE.MeshPhongMaterial({ color: color });
			var w = new THREE.Mesh(geometry, material);
			w.rotation.y = Math.atan((from[1] - to[1]) / (from[0] - to[0]));
			w.position.set((from[0] + to[0]) / 2, height / 2, -(from[1] + to[1]) / 2);
			if (hasDoor) {
				var door = new THREE.Mesh(
					new THREE.BoxGeometry(doorDim[0], doorDim[1], doorDim[2]),
					material
				);
				door.rotation.y = Math.atan((from[1] - to[1]) / (from[0] - to[0]));
				door.position.set(doorPosition[0], doorDim[1] / 2, -doorPosition[1]);
				var csgWall = new CSG();

				csgWall.subtract([w, door]);
				w = csgWall.toMesh();

				var doorG = new THREE.Group();
				var coords = [door.position.x,
				door.position.y,
				door.position.z];
				var rot = door.rotation.y;
				door.position.set(doorDim[0] / 2, doorDim[1] / 2, 0);
				door.rotation.y = 0;
				var doorG = new THREE.Group();
				doorG.add(door);
				var doorGG = new THREE.Group();
				doorG.rotation.y = rot;
				doorGG.add(doorG);
				doorGG.position.set(coords[0], 0, coords[2]);
				var v = [doorDim[0] / 2 * (from[0] - to[0]) / length,
					0,
				doorDim[0] / 2 * (from[1] - to[1]) / length];
				doorGG.position.x += v[0];
				doorGG.position.z += v[2];
				scene.add(doorGG);
				doors.push(doorGG);
			}
			w.castShadow = true;
			w.receiveShadow = true;
			return w;
		}

		var geometry, material;

		const wallThickness = .2;
		const wallColor = 'salmon';
		const doorColor = 'blue';

		scene.add(wall([3, -7 - wallThickness / 2], [3, -1 - wallThickness / 2], 3, wallThickness, wallColor));
		scene.add(wall([3 - wallThickness / 2, -7], [-4 - wallThickness / 2, -7], 3, wallThickness, wallColor));
		scene.add(wall([-4, -7 + wallThickness / 2], [-4, 5 + wallThickness / 2], 3, wallThickness, wallColor));
		scene.add(wall([-4 + wallThickness / 2, 5], [9 + wallThickness / 2, 5], 3, wallThickness, wallColor));
		scene.add(wall([9, 5 - wallThickness / 2], [9, -1 - wallThickness / 2], 3, wallThickness, wallColor));
		scene.add(wall([9 - wallThickness / 2, -1], [3 - wallThickness / 2, -1], 3, wallThickness, wallColor));
		scene.add(wall([3, -3.5], [3, -2.5], 2, 2 * wallThickness, doorColor));
		scene.add(wall([5, -1 + wallThickness / 2],
			[5, 5 - wallThickness / 2],
			3,
			wallThickness,
			wallColor,
			true, [5, 1], [1.5, 2, .3]));
		scene.add(wall([3, -1 + wallThickness / 2], [3, 1], 3, wallThickness, wallColor));
		var rightCut = wall([3 + wallThickness, -1 + wallThickness / 2], [3 + wallThickness, 1.5], 3, wallThickness, wallColor);
		scene.add(wall([-1, 2], [-1, 5 - wallThickness / 2], 3, wallThickness, wallColor));
		var leftCut = wall([-1 - wallThickness, 1.5], [-1 - wallThickness, 5 - wallThickness / 2], 3, wallThickness, wallColor);
		var tilted = wall([-1.0735848395, 2.092452789],
			[3.0735843719, 0.9075455745],
			3,
			wallThickness,
			wallColor,
			true, [0, 2.35], [1.5, 2, 1.7]);

		var csgTiled = new CSG();
		csgTiled.subtract([tilted, leftCut, rightCut]);
		scene.add(csgTiled.toMesh());
		scene.add(wall(
			[-4 + wallThickness / 2, -4],
			[3 - wallThickness / 2, -4],
			3,
			wallThickness,
			wallColor,
			true, [-2, -4], [1.5, 2, .3]));

		var toasters = [];

		var t1 = new THREE.Group();

		geometry = new THREE.CylinderGeometry(1, 1.3, 2, 32, 20);
		material = new THREE.MeshPhongMaterial({ color: 'white' });
		var part = new THREE.Mesh(geometry, material);
		part.position.set(0, 1.3, 0);
		part.scale.z = 1.5;

		var csgBody = new CSG();
		geometry = new THREE.BoxGeometry(.4, 1.3, 1.3);
		material = new THREE.MeshPhongMaterial({ color: 'yellow' });
		var slice1hole = new THREE.Mesh(geometry, material);
		slice1hole.position.set(.3, 2.2, 0);
		var slice2hole = new THREE.Mesh(geometry, material);
		slice2hole.position.set(-.3, 2.1, 0);
		csgBody.subtract([part, slice1hole, slice2hole]);

		t1.add(csgBody.toMesh());

		material = new THREE.MeshPhongMaterial({ color: 'grey' });
		geometry = new THREE.CylinderGeometry(1.28, 1.28, .3, 32, 20);
		part = new THREE.Mesh(geometry, material);
		part.position.set(0, .15, 0);
		part.scale.z = 1.5;
		t1.add(part);

		geometry = new THREE.BoxGeometry(.3, 1, 1);
		material = new THREE.MeshPhongMaterial({ color: 'yellow' });
		var slice1 = new THREE.Mesh(geometry, material);
		slice1.position.set(.3, 2.2, 0);
		var slice2 = new THREE.Mesh(geometry, material);
		slice2.position.set(-.3, 2.1, 0);
		t1.add(slice1);
		t1.add(slice2);


		var lever = new THREE.Group();

		geometry = new THREE.SphereGeometry(.1, 32, 16);
		material = new THREE.MeshPhongMaterial({ color: 'red' });
		var ball = new THREE.Mesh(geometry, material);

		geometry = new THREE.CylinderGeometry(.03, .03, .5, 32, 20);
		material = new THREE.MeshPhongMaterial({ color: 'red' });
		var long = new THREE.Mesh(geometry, material);
		long.rotation.x = Math.PI / 2 - Math.atan(.45 / 2);
		long.position.set(0, -.05, -.25);

		lever.add(long);
		lever.add(ball);

		lever.position.set(0, 2, 1.7);

		t1.add(lever);

		geometry = new THREE.BoxGeometry(.2, 1.75, .2);
		material = new THREE.MeshPhongMaterial({ color: 'black' });
		part = new THREE.Mesh(geometry, material);
		part.position.set(0, 1.42, 1.675);
		part.rotation.x = -Math.atan(.45 / 2);
		t1.add(part);

		geometry = new THREE.CylinderGeometry(.75, .95, .3, 64, 10);
		material = new THREE.MeshPhongMaterial({ color: 0x800507 });
		part = new THREE.Mesh(geometry, material);
		part.position.set(0, 2.3, 0);
		part.scale.z = 1.5;

		geometry = new THREE.BoxGeometry(.47, 1.3, 1.37);
		var slice1hole = new THREE.Mesh(geometry, material);
		var slice2hole = new THREE.Mesh(geometry, material);
		slice1hole.position.set(.3, 2.2, 0);
		slice2hole.position.set(-.3, 2.1, 0);
		csgBody = new CSG();
		csgBody.subtract([part, slice1hole, slice2hole]);
		t1.add(csgBody.toMesh());


		t1.position.set(7, 0, -2);
		toasters.push(t1);
		scene.add(t1);

		var t2 = t1.clone();
		t2.scale.set(.5, .5, .5);
		t2.position.set(0, 10, 0);
		toasters.push(t2);
		scene.add(t2);

		t1.scale.set(.5, .5, .5);


		geometry = new THREE.CylinderGeometry(.1, .1, 1.2, 16, 8);
		material = new THREE.MeshPhongMaterial({ color: 'orange' });
		var leftLeg = new THREE.Mesh(geometry, material);
		leftLeg.position.y = -.6;
		leftLeg.position.x = .2;
		leftLeg.rotation.z = Math.PI / 20;
		var rightLeg = new THREE.Mesh(geometry, material);
		rightLeg.position.y = -.6;
		rightLeg.position.x = -.2;
		rightLeg.rotation.z = -Math.PI / 20;
		var body = new THREE.Mesh(geometry, material);
		body.position.y = .6;

		geometry = new THREE.SphereGeometry(.5, 32, 16);
		var head = new THREE.Mesh(geometry, material);
		head.position.y = 1.7;

		var person = new THREE.Group();
		person.add(leftLeg);
		person.add(rightLeg);
		person.add(body);
		person.add(head);

		scene.add(person);

		var alpha = Math.PI / 4;
		var slice1Bounce = .7;
		var personAlpha = 0;
		var personX, personZ;
		var doorAlpha = 0;
		var doorStep = 0.02;
		function drawFrame() {
			requestAnimationFrame(drawFrame);

			for (var i = 0; i < toasters.length; ++i) {
				toasters[i].children[2].position.y = 2.4 - .7 * Math.sin(alpha) * Math.sin(alpha) - .4 * Math.cos(alpha);
				toasters[i].children[3].position.y = 2.4 - .9 * Math.sin(alpha + .3) * Math.sin(alpha + .3) - .9 * Math.cos(alpha);
				toasters[i].children[4].position.y = .8 * Math.sin(alpha + .1) + 1.5;
				toasters[i].children[4].position.z = 2 - .18 * Math.sin(alpha + .1);
			}

			for (var i = 0; i < doors.length; ++i) {
				doors[i].rotation.y += doorStep;
				if (doors[i].rotation.y > 3 * Math.PI / 4 ||
					doors[i].rotation.y < 0)
					doorStep = -doorStep;
			}

			personX = 9 * Math.sqrt(Math.abs(Math.cos(personAlpha)));
			if (Math.cos(personAlpha) < 0) personX = -personX;
			personZ = 9 * Math.sqrt(Math.abs(Math.sin(personAlpha)));
			if (Math.sin(personAlpha) < 0) personZ = -personZ;
			person.position.set(1 + personX,
				.6,
				personZ);
			person.rotation.y = -personAlpha;

			personAlpha += 0.02;//fix
			alpha += 0.1;
			renderer.render(scene, camera);
		};

	</script>

</body>

</html>